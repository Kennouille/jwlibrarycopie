<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fusionner Fichiers JW Library</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      color: #333;
    }

    .container {
      background-color: #f9f9f9;
      border-radius: 10px;
      padding: 25px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    h2 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 25px;
    }

    label {
      display: block;
      margin: 15px 0 5px;
      font-weight: bold;
    }

    input[type="file"], input[type="datetime-local"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      background-color: white;
    }

    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
      margin: 20px 0;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #2980b9;
    }

    #progressContainer {
      width: 100%;
      background-color: #ecf0f1;
      border-radius: 5px;
      margin: 20px 0;
      height: 30px;
      overflow: hidden;
      position: relative;
    }

    #progressBar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      transition: width 0.3s ease-out;
    }

    #progressText {
      position: absolute;
      width: 100%;
      text-align: center;
      line-height: 30px;
      color: #2c3e50;
      font-weight: bold;
    }

    #progressDetails {
      margin-top: 5px;
      font-size: 14px;
      color: #7f8c8d;
      min-height: 20px;
      text-align: center;
    }

    .step-indicator {
      display: flex;
      justify-content: space-between;
      margin: 25px 0 15px;
      position: relative;
    }

    .step-indicator::before {
      content: "";
      position: absolute;
      top: 15px;
      left: 0;
      right: 0;
      height: 3px;
      background-color: #ecf0f1;
      z-index: 0;
    }

    .step {
      text-align: center;
      z-index: 1;
      background-color: #f9f9f9;
      padding: 0 10px;
    }

    .step .step-circle {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: #bdc3c7;
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 5px;
    }

    .step.completed .step-circle {
      background-color: #2ecc71;
    }

    .step.active .step-circle {
      background-color: #3498db;
      animation: pulse 1.5s infinite;
    }

    .conflict-container {
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 15px;
      margin: 15px 0;
      background-color: white;
    }

    .conflict-item {
      margin-bottom: 10px;
      padding: 10px;
      border-bottom: 1px solid #eee;
    }

    #download {
      display: block;
      text-align: center;
      padding: 15px;
      background-color: #2ecc71;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      margin-top: 20px;
      font-weight: bold;
      transition: background-color 0.3s;
    }

    #download:hover {
      background-color: #27ae60;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    .hidden {
      display: none !important;
    }

    /* Animation de construction */
    .file-construction {
        margin: 20px 0;
        text-align: center;
    }

    .construction-animation {
        display: flex;
        justify-content: center;
        gap: 5px;
        height: 30px;
        margin-bottom: 10px;
    }

    .construction-block {
        width: 6px;
        background: linear-gradient(to top, #3498db, #2ecc71);
        border-radius: 3px;
        animation: blockGrow 1s infinite ease-in-out;
        margin: 0 2px;
    }

    @keyframes blockGrow {
        0%, 100% { height: 30%; }
        50% { height: 80%; }
    }

    @keyframes blockWave {
        0%, 100% { height: 20%; }
        50% { height: 100%; opacity: 1; }
    }

    .construction-text {
        font-size: 14px;
        color: #7f8c8d;
        font-style: italic;
    }

    .construction-dots::after {
        content: '...';
        animation: dotPulse 1.5s infinite steps(4);
    }

    @keyframes dotPulse {
        0% { content: '.'; }
        33% { content: '..'; }
        66% { content: '...'; }
    }

    /* Remplacez votre CSS existant par ceci */
    .progress-bar-animated {
        position: relative;
        overflow: hidden;
    }

    .progress-bar-animated::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg,
            rgba(255,255,255,0) 0%,
            rgba(255,255,255,0.8) 50%,
            rgba(255,255,255,0) 100%);
        animation: shine 2s infinite;
    }

    @keyframes shine {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }

    .site-message {
      max-width: 800px;
      margin: 50px auto 20px;
      font-size: 14px;
      color: #555;
      text-align: center;
      padding: 0 15px;
      line-height: 1.6;
    }

    .site-message a {
      color: #2980b9;
      text-decoration: none;
    }

    .site-message a:hover {
      text-decoration: underline;
    }

    .footer {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
      border-top: 1px solid #ccc;
      padding: 15px;
      max-width: 800px;
      margin: 0 auto 30px;
    }

    .footer-logo {
      height: 40px;
    }

    .footer-text {
      font-size: 13px;
      color: #888;
    }

    .security-box {
      background-color: #eaeaea; /* plus foncé */
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
      margin-bottom: 30px;
      font-size: 13.5px; /* légèrement plus petit */
      color: #2c2c2c; /* texte un peu plus sombre */
    }


    .security-columns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-top: 15px;
    }

    .security-block p {
      margin: 0 0 10px;
    }

    .security-block ul {
      padding-left: 20px;
      margin: 0;
    }

    .security-block ul li {
      margin-bottom: 8px;
    }

    .security-box {
      border: 1px solid #ccc;
    }

    .hidden {
      display: none;
    }

    #manualDownloadMessage {
      margin-bottom: 10px;
      white-space: pre-wrap;
      font-family: system-ui;
    }

    .btn-primary {
      background-color: #007bff;
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
    }

    .btn-primary:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .tabs { margin-top: 20px; }
    .tab-btn {
      background-color: white;
      color: #007bff;
      border: 2px solid #007bff;
      border-radius: 12px;
      font-weight: bold;
      padding: 12px 24px;
      font-size: 16px;
      width: 100%;
      transition: 0.3s;
      margin-bottom: 10px;

      /* NOUVEAU POUR LA BARRE DE PROGRÈS */
      position: relative; /* Pour positionner la barre à l'intérieur */
      overflow: hidden;   /* Pour cacher ce qui dépasse de la barre */
      display: flex;      /* Pour centrer le texte et la barre si besoin */
      align-items: center;
      justify-content: center;
      padding: 0; /* Réinitialiser le padding pour le gérer sur le span du texte */
    }

    .tab-btn .tab-text {
      position: relative; /* Pour s'assurer que le texte est au-dessus de la barre */
      z-index: 2;         /* Assure que le texte est visible au-dessus de la barre */
      padding: 12px 24px; /* Remettre le padding sur le texte */
      width: 100%;        /* Pour que le texte occupe toute la largeur disponible */
      text-align: center; /* Centrer le texte */
    }

    .tab-btn .progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%; /* Largeur initiale */
      background-color: rgba(0, 123, 255, 0.3); /* Couleur de la barre, légèrement transparente */
      transition: width 0.1s linear; /* Animation douce de la largeur */
      z-index: 1; /* S'assure que la barre est en arrière-plan par rapport au texte */
    }

    /* Style de la barre pour le bouton actif */
    .tab-btn.active {
      background-color: #007bff;
      color: white;
    }

    /* Ajustement de la couleur de la barre pour le bouton actif */
    .tab-btn.active .progress-bar {
      background-color: rgba(255, 255, 255, 0.3); /* Barre plus claire sur fond bleu */
    }

    .tab-content {
      margin-top: 15px;
    }
    .hidden {
      display: none;
    }
    .preview-row {
      display: flex;
      border-bottom: 1px solid #ddd;
      padding: 6px 0;
    }
    .preview-cell {
      flex: 1;
      padding: 0 10px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .preview-controls {
      text-align: center;
    }
    .preview-cell.diff {
      background-color: #fff7dc;
    }


    td pre {
      white-space: pre-wrap;       /* Forcer retour à la ligne */
      word-wrap: break-word;       /* Casser les longs mots */
      overflow-wrap: break-word;   /* Compatibilité */
      max-width: 100%;             /* Ne jamais dépasser la cellule */
      font-size: 14px;             /* Réduire un peu si nécessaire */
      margin: 0;                   /* Enlever marges inutiles */
    }

    #merge-step-indicator {
      display: flex;
      justify-content: space-between;
      margin: 25px 0 15px;
      position: relative;
    }

    #merge-step-indicator::before {
      content: "";
      position: absolute;
      top: 15px;
      left: 0;
      right: 0;
      height: 3px;
      background-color: #ecf0f1;
      z-index: 0;
    }

    #merge-step-indicator .step {
      text-align: center;
      z-index: 1;
      background-color: #f9f9f9;
      padding: 0 10px;
    }

    #merge-step-indicator .step .step-circle {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: #bdc3c7;
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 5px;
    }

    #merge-step-indicator .step.completed .step-circle {
      background-color: #2ecc71;
    }

    #merge-step-indicator .step.active .step-circle {
      background-color: #3498db;
      animation: pulse 1.5s infinite;
    }

    .merge-indicator {
      display: flex;
      justify-content: space-between;
      margin: 30px 0 15px;
      position: relative;
    }

    .merge-indicator::before {
      content: "";
      position: absolute;
      top: 15px;
      left: 0;
      right: 0;
      height: 3px;
      background-color: #ecf0f1;
      z-index: 0;
    }

    .merge-step {
      text-align: center;
      z-index: 1;
      background-color: #f9f9f9;
      padding: 0 10px;
    }

    .merge-step .merge-step-circle {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: #bdc3c7;
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .merge-step.completed .merge-step-circle {
      background-color: #2ecc71;
    }

    .merge-step.active .merge-step-circle {
      background-color: #3498db;
      animation: pulse 1.5s infinite;
    }

    .preview-truncated {
      max-height: 6em;
      overflow: hidden;
      position: relative;
    }

    .preview-truncated .read-more {
      color: #007bff;
      cursor: pointer;
      font-weight: bold;
      display: inline-block;
      margin-top: 5px;
    }

    .note-modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    .note-modal-content {
      background: white;
      padding: 30px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: 8px;
      position: relative;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
    }

    .note-modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #e74c3c;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
    }

    .note-modal-text {
      white-space: pre-wrap;
      margin-top: 50px;
    }

    /* Style du conteneur principal du Tom Select */
    .tom-select {
        /* Par exemple, une bordure plus prononcée */
        border: 1px solid #7f8c8d; /* Une couleur gris-bleu foncé */
        border-radius: 4px; /* Des coins légèrement arrondis */
        box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Une petite ombre pour le faire ressortir */
    }

    /* Style de la zone de contrôle (où sont les tags sélectionnés et le champ de saisie) */
    .tom-select .ts-control {
        padding: 6px 10px; /* Augmenter un peu le padding si désiré */
        background-color: #f8f9fa; /* Un fond légèrement plus clair que le blanc pur */
        border: none; /* Enlève la bordure interne si le .tom-select a déjà une bordure */
        font-weight: normal; /* S'assurer que le texte n'est pas en gras sauf si vous le voulez */
    }

    /* Style du champ de saisie réel (là où l'on tape pour rechercher) */
    .tom-select .ts-control input[type="text"] {
        font-weight: bold; /* Le texte tapé sera en gras */
        color: #2c3e50; /* Une couleur de texte un peu plus foncée */
    }

    /* Style des tags (pastilles) déjà sélectionnés */
    .tom-select .item {
        background-color: #3498db; /* Un fond bleu pour les tags */
        color: white; /* Texte blanc sur les tags */
        border-radius: 3px; /* Coins arrondis pour les tags */
        padding: 2px 8px; /* Padding interne des tags */
        margin: 2px; /* Marge entre les tags */
        font-weight: bold; /* Texte des tags en gras */
    }

    /* Style du bouton de suppression sur les tags */
    .tom-select .item .remove {
        color: #ecf0f1; /* Couleur du X pour la suppression */
        margin-left: 5px; /* Espace entre le texte du tag et le X */
        font-weight: bold; /* Rendre le X plus visible */
    }

    /* Style de la liste déroulante (le menu qui s'ouvre) */
    .tom-select .ts-dropdown {
        border: 1px solid #bdc3c7; /* Bordure plus visible pour le dropdown */
        border-top: none; /* Pas de bordure en haut car elle se connecte au ts-control */
        box-shadow: 0 4px 8px rgba(0,0,0,0.15); /* Ombre plus prononcée pour le dropdown */
        background-color: white; /* Fond blanc du dropdown */
    }

    /* Style des options individuelles dans la liste déroulante */
    .tom-select .option {
        padding: 8px 10px; /* Padding des options */
        /* font-weight: normal; */ /* Par défaut, pas de gras */
    }

    /* Style des options au survol */
    .tom-select .option.active {
        background-color: #e8f5fd; /* Fond bleu clair au survol */
        color: #2c3e50;
    }

    /* Style des options déjà sélectionnées dans le dropdown */
    /* Cela s'applique si vous aviez le plugin checkbox_options ou si elles sont juste marquées textuellement */
    .tom-select .option.selected {
        background-color: #d1e7f5; /* Un fond légèrement différent pour les options sélectionnées */
        font-weight: bold; /* Rendre le texte des options sélectionnées en gras */
    }



  </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/css/tom-select.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/js/tom-select.complete.min.js"></script>
</head>
<body>
<div class="container">
  <h2>Fusionner des fichiers JW Library</h2>
  <div style="text-align: right; margin-bottom: 20px;">
    <img src="https://flagcdn.com/fr.svg" width="24" alt="fr" onclick="switchLanguage('fr')" style="cursor:pointer; margin-left: 5px;">
    <img src="https://flagcdn.com/es.svg" width="24" alt="es" onclick="switchLanguage('es')" style="cursor:pointer; margin-left: 5px;">
    <img src="https://flagcdn.com/gb.svg" width="24" alt="en" onclick="switchLanguage('en')" style="cursor:pointer; margin-left: 5px;">
    <img src="https://flagcdn.com/it.svg" width="24" alt="it" onclick="switchLanguage('it')" style="cursor:pointer; margin-left: 5px;">
    <img src="https://flagcdn.com/br.svg" width="24" alt="pt" onclick="switchLanguage('pt')" style="cursor:pointer; margin-left: 5px;">
    <img src="https://flagcdn.com/de.svg" width="24" alt="de" onclick="switchLanguage('de')" style="cursor:pointer; margin-left: 5px;">
  </div>
  <div id="footer-security-fr" class="footer-security-box" style="display: none">...</div>
  <div id="footer-security-en" class="footer-security-box" style="display: none">...</div>
  <div id="footer-security-es" class="footer-security-box" style="display: none">...</div>
  <div id="footer-security-it" class="footer-security-box" style="display: none">...</div>
  <div id="footer-security-pt" class="footer-security-box" style="display: none">...</div>
  <div id="footer-security-de" class="footer-security-box" style="display: none">...</div>



  <label for="file1">Sélectionner le premier fichier (.jwlibrary) :</label>
  <input type="file" id="file1" accept=".jwlibrary">

  <label for="file2">Sélectionner le deuxième fichier (.jwlibrary) :</label>
  <input type="file" id="file2" accept=".jwlibrary">

  <label for="local_datetime">Date et heure locales actuelles :</label>
  <input type="datetime-local" id="local_datetime" name="local_datetime" required>

  <div class="step-indicator">
    <div class="step" id="step1">
      <div class="step-circle">1</div>
      <div>Chargement</div>
    </div>
    <div class="step" id="step2">
      <div class="step-circle">2</div>
      <div>Extraction</div>
    </div>
    <div class="step" id="step3">
      <div class="step-circle">3</div>
      <div>Analyse</div>
    </div>
    <div class="step" id="step4">
      <div class="step-circle">4</div>
      <div>Détection</div>
    </div>
    <div class="step" id="step5">
      <div class="step-circle">5</div>
      <div>Prêt...</div>
    </div>
  </div>

  <div id="progressContainer">
    <div id="progressBar"></div>
    <div id="progressText">0%</div>
  </div>

  <div id="progressDetails">Prêt à commencer...</div>

  <div id="construction-container" class="file-construction hidden">
      <div class="construction-animation" id="construction-animation">
          <!-- Les blocs seront ajoutés par JavaScript -->
      </div>
      <div class="construction-text">
          Ce process peut durer jusqu'à 4 minutes pour des gros fichiers<span class="construction-dots"></span>
      </div>
  </div>

  <button id="mergeButton" onclick="startPreparation()">Charger, Extraire & Analyser</button>

  <div id="merge-summary" class="conflict-container hidden">
    <h3>Résumé de la prévisualisation</h3>
    <p id="summary-text">
      Les deux fichiers ont été analysés et fusionnés avec succès.
      Les notes, surlignages, marque-pages, playlists et autres contenus identiques ont été conservés.
      Les éléments uniques de chaque fichier ont été ajoutés automatiquement.
    </p>
  </div>
  <div id="manualDownloadContainer" class="hidden" style="margin-top: 20px;">
    <p id="manualDownloadMessage"></p>
    <button id="manualDownloadBtn" class="btn btn-primary"></button>
  </div>
</div>

<div id="preview-section" class="hidden">
  <h3>Prévisualisation et Choix Utilisateur</h3>

  <div class="tabs">
    <button class="tab-btn" onclick="showTab('notes')">
      <span class="tab-text">📝 Notes</span>
      <span class="progress-bar"></span>
    </button>
    <button class="tab-btn" onclick="showTab('bookmarks')">
      <span class="tab-text">🔖 Marque-pages</span>
      <span class="progress-bar"></span>
    </button>
    <button class="tab-btn" onclick="showTab('tags')">
      <span class="tab-text">🏷️ Catégories</span>
      <span class="progress-bar"></span>
    </button>
  </div>

  <div style="margin-top: 30px; text-align: center;">
    <button class="btn btn-primary" onclick="startMerge()">✅ Lancer la fusion finale</button>
  </div>

  <div id="preview-content">
    <!-- Ces trois divs doivent exister et avoir les bons IDs -->
    <div id="tab-notes" class="tab-content hidden"></div>
    <div id="tab-bookmarks" class="tab-content hidden"></div>
    <div id="tab-tags" class="tab-content hidden"></div>
  </div>

  <div class="merge-indicator">
    <div class="merge-step" id="mergeStep1">
      <div class="merge-step-circle">1</div>
      <div>Upload</div>
    </div>
    <div class="merge-step" id="mergeStep2">
      <div class="merge-step-circle">2</div>
      <div>Fusion</div>
    </div>
    <div class="merge-step" id="mergeStep3">
      <div class="merge-step-circle">3</div>
      <div>ZIP</div>
    </div>
    <div class="merge-step" id="mergeStep4">
      <div class="merge-step-circle">4</div>
      <div>Finalisation</div>
    </div>
    <div class="merge-step" id="mergeStep5">
      <div class="merge-step-circle">5</div>
      <div>Terminé</div>
    </div>
  </div>

  <div style="margin-top: 30px; text-align: center;">
    <button class="btn btn-primary" onclick="startMerge()">✅ Lancer la fusion finale</button>
  </div>
</div>

<div id="noteModal" class="note-modal">
  <div class="note-modal-content">
    <button id="noteModalClose" class="note-modal-close">Fermer</button>
    <div id="noteModalText" class="note-modal-text"></div>
  </div>
</div>


<div id="errorDisplayWrapper" style="
  max-width: 800px;
  margin: 30px auto 0;
  display: none;
  text-align: center;
">
  <div id="errorDisplay" style="
    color: #e74c3c;
    font-weight: bold;
    padding: 15px;
    border: 1px solid #e74c3c;
    border-radius: 5px;
    background-color: #fdecea;
    white-space: pre-wrap;
    margin-bottom: 10px;
  "></div>
  <button onclick="copyError()" style="
    background-color: #e74c3c;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
  ">📋 Copier le message</button>
</div>
<div id="footer-message" class="site-message"></div>

<footer class="footer">
  <a href="https://wa.me/528118594482" target="_blank" title="Me contacter par WhatsApp">
    <img src="images/Logo KM.png" alt="Logo KM" class="footer-logo">
  </a>
  <span id="footer-copy" class="footer-text"></span>
</footer>


<script type="module">
  import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

  const supabase = createClient("https://mngggybayjooqkzbhvqy.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1uZ2dneWJheWpvb3FremJodnF5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjY2MTU3NDgsImV4cCI6MjA0MjE5MTc0OH0.lnOqnq1AwN41g4xJ5O9oNIPBQqXYJkSrRhJ3osXtcsk");

  const BASE_URL = "https://web-production-0d059.up.railway.app/";
  const currentTagSelections = {};

  let currentProgress = 0;
  let cachedNotesTabHTML = null; // Variable pour stocker le HTML de l'onglet Notes
  let notesDataHash = null;      // Pour stocker un "hash" ou une représentation de l'état actuel des données de notes
                               // afin de savoir si les données ont changé.
  const labels = {
    Title: "Titre",
    Content: "Note",
    Name: "Catégorie"
  };

  const fieldFilter = {
    notes: ["Title", "Content"],
    bookmarks: ["Title"],
    tags: ["Name"]
  };

  async function updateProgress(targetPercent, message, step) {
    return new Promise(resolve => {
      const startPercent = currentProgress;
      const duration = 500;
      const startTime = performance.now();

      const animate = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        currentProgress = startPercent + (targetPercent - startPercent) * progress;

        document.getElementById("progressBar").style.width = currentProgress + "%";
        document.getElementById("progressText").textContent = Math.round(currentProgress) + "%";
        if (message) document.getElementById("progressDetails").textContent = message;

        if (step) updateStepIndicator(step, currentProgress);

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };

      requestAnimationFrame(animate);
    });
  }

  function showError(message) {
    const wrapper = document.getElementById("errorDisplayWrapper");
    const el = document.getElementById("errorDisplay");
    el.textContent = message;
    wrapper.style.display = "block";
  }

  function copyError() {
    const text = document.getElementById("errorDisplay").textContent;
    navigator.clipboard.writeText(text).then(() => {
      alert("Message copié !");
    });
  }

  function updateStepIndicator(step) {
    const allSteps = document.querySelectorAll('.step');
    allSteps.forEach((el, index) => {
      el.classList.remove('active', 'completed');
      if (index + 1 < step) el.classList.add('completed');
      else if (index + 1 === step) el.classList.add('active');
    });
  }

  function appendToMergeLog(text, isError = false) {
    const log = document.getElementById('merge-log');
    if (!log) return;

    const entry = document.createElement('div');
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
    entry.style.color = isError ? '#ff6b6b' : '#adb5bd';
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
  }

  async function simulateProcessing(duration, targetPercent, message, step) {
    const startPercent = currentProgress;
    const startTime = Date.now();

    while (Date.now() - startTime < duration) {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const current = startPercent + (targetPercent - startPercent) * progress;

      await updateProgress(current, message, step);
      await new Promise(r => setTimeout(r, 50));
    }
  }

  async function uploadWithProgress(url, formData) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();

      xhr.upload.onprogress = (e) => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 30);
          updateProgress(20 + percent, `Upload: ${Math.round(e.loaded / 1024)}KB/${Math.round(e.total / 1024)}KB`, 2);
        }
      };

      xhr.onload = () => resolve(xhr.response);
      xhr.onerror = () => reject(new Error("Upload failed"));

      xhr.open("POST", url);
      xhr.setRequestHeader("ngrok-skip-browser-warning", "true");
      xhr.responseType = "json";
      xhr.send(formData);
    });
  }

  function showConstructionAnimation() {
      const container = document.getElementById('construction-container');
      const animationEl = document.getElementById('construction-animation');

      // Créer 10 barres animées
      animationEl.innerHTML = '';
      for (let i = 0; i < 10; i++) {
          const block = document.createElement('div');
          block.className = 'construction-block';
          block.style.animationDelay = `${i * 0.2}s`;
          animationEl.appendChild(block);
      }

      container.classList.remove('hidden');
  }

  async function hashBlob(blob) {
      const buffer = await blob.arrayBuffer();
      const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
      return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

  async function logMergeToSupabase(status, message = "") {
    let country = "unknown";
    let city = "unknown";

    try {
      const res = await fetch("https://ipapi.co/json/");
      if (res.ok) {
        const json = await res.json();
        country = json.country || "unknown"; // Exemple: "FR"
        city = json.city || "unknown";       // Exemple: "Lyon"
      }
    } catch (e) {
      console.warn("🌐 Impossible de récupérer la localisation :", e.message);
    }

    const logEntry = {
      status,
      message,
      lang: window.currentLang || "unknown",
      platform: navigator.platform || "unknown",
      browser: navigator.userAgent || "unknown",
      country,
      city
    };

    const { data, error } = await supabase
      .from("merge_logs")
      .insert([logEntry]);

    if (error) {
      console.warn("❌ Supabase log failed:", error.message);
    } else {
      console.log("✅ Supabase log enregistré:", data);
    }
  }

  let previewDataEdited = {}; // Pour stocker les modifications utilisateur

  function escapeHTML(str) {
    if (typeof str !== 'string') return '';
    return str.replace(/[&<>'"]/g, tag => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', "'": '&#39;', '"': '&quot;'
    }[tag]));
  }

  function renderEditableField(table, fileKey, index, field, value, labels) {
    const escaped = escapeHTML(value || '');
    const id = `editable-${table}-${fileKey}-${index}-${field}`;
    const noteObj = previewDataEdited.notes[fileKey]?.[index] || {};
    const noteId = noteObj.NoteId;

    // 🔒 Le titre est en lecture seule
    if (table === "notes" && field === "Title") {
      return `<div><strong>${labels[field]} :</strong><br>
        <input type="text" value="${escaped}" style="width:100%;" readonly></div>`;
    }

    // 📝 Zone de texte pour "Content" avec un Tom Select pour les catégories
    if (table === "notes" && field === "Content") {
        const tagIds = Array.isArray(noteObj.TagIds) ? noteObj.TagIds : [];
        // Assurez-vous que tagIds contient des nombres si vos TagId sont des nombres
        const currentNoteTagIds = tagIds.map(id => parseInt(id)).filter(id => !isNaN(id));

        // Préparez les options pour le sélecteur Tom Select
        // Nous allons générer toutes les options possibles ici,
        // et Tom Select s'occupera de l'initialisation des sélections et de la recherche.
        const allAvailableTags = previewDataEdited.tags[fileKey] || [];
        const optionsHtml = allAvailableTags.map(cat => {
            // Marquer comme "selected" si ce tag est déjà dans les tags de la note courante
            const selected = currentNoteTagIds.includes(cat.TagId) ? "selected" : "";
            return `<option value="${cat.TagId}" ${selected}>${escapeHTML(cat.Name)}</option>`;
        }).join("");

        return `<div>
          <strong>${labels[field]} :</strong><br>
          <textarea class="editable" id="${id}" data-table="${table}" data-file="${fileKey}" data-index="${index}" data-field="${field}" rows="4" style="width:100%;">${escaped}</textarea>
          <a href="#" class="show-full-note" data-content="${escaped}" data-label="${labels[field]}" style="display:inline-block;margin-top:5px;">🔍 Voir en grand</a>
          <br><br>
          <label>Catégories :</label><br>
          <select id="${id}-tomselect" class="note-tags-tomselect" multiple
                  data-table="${table}" data-file="${fileKey}" data-index="${index}" data-noteid="${noteId}"
                  placeholder="Sélectionnez des catégories..."
                  style="width:100%; margin-top:4px;">
              ${optionsHtml}
          </select>
        </div>`;
    }

    // 🔤 Champs standards (ex : Name)
    return `<div><strong>${labels[field]} :</strong><br>
      <input type="text" class="editable" id="${id}" data-table="${table}" data-file="${fileKey}" data-index="${index}" data-field="${field}" value="${escaped}" style="width:100%;">
    </div>`;
  }


  // Variables pour gérer les animations de barre de progression
  const progressAnimations = {};
  const MIN_LOAD_TIME_MS = 3000; // Ou 30000ms pour 30 secondes

  function startProgressBarAnimation(buttonElement, tabName) {
      const progressBar = buttonElement.querySelector('.progress-bar');
      if (!progressBar) return;

      // Réinitialiser la barre en enlevant d'abord toutes les propriétés de style en ligne
      progressBar.style.removeProperty('width');     // <-- Important pour que le CSS width: 0% s'applique
      progressBar.style.removeProperty('transition'); // <-- C'EST LA LIGNE MANQUANTE / CRUCIALE

      // Maintenant, appliquez la transition désirée pour cette animation
      // Ce n'est pas strictement nécessaire ici si le CSS est parfait,
      // mais peut servir de filet de sécurité.
      // progressBar.style.transition = 'width 0.1s linear'; // Optionnel, car le CSS le fait.

      // Annuler toute animation existante pour cet onglet
      if (progressAnimations[tabName]) {
          cancelAnimationFrame(progressAnimations[tabName].animationFrame);
          clearTimeout(progressAnimations[tabName].timeoutId);
      }

      const startTime = Date.now();
      let animationFrameId;
      let timeoutId;
      let finishedLoading = false;

      const animate = () => {
          if (finishedLoading) {
              progressBar.style.width = '100%';
              progressBar.style.transition = 'width 0.3s ease-out'; // Transition de fin
              return;
          }

          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / MIN_LOAD_TIME_MS, 0.95);

          progressBar.style.width = `${progress * 100}%`;

          animationFrameId = requestAnimationFrame(animate);
      };

      animationFrameId = requestAnimationFrame(animate);

      timeoutId = setTimeout(() => {
          if (!finishedLoading) {
              progressBar.style.width = '95%';
          }
      }, MIN_LOAD_TIME_MS);

      progressAnimations[tabName] = {
          animationFrame: animationFrameId,
          timeoutId: timeoutId,
          progressBar: progressBar,
          markFinished: () => { finishedLoading = true; }
      };
  }

  // Votre fonction finishProgressBarAnimation devrait toujours être celle-ci :
  function finishProgressBarAnimation(buttonElement, tabName) {
      if (progressAnimations[tabName]) {
          const { progressBar, animationFrame, timeoutId, markFinished } = progressAnimations[tabName];

          markFinished();
          progressBar.style.width = '100%';
          progressBar.style.transition = 'width 0.3s ease-out';

          setTimeout(() => {
              progressBar.style.width = '0%';
              progressBar.style.removeProperty('transition'); // Cette ligne est cruciale aussi !
          }, 300);

          cancelAnimationFrame(animationFrame);
          clearTimeout(timeoutId);
          delete progressAnimations[tabName];
      }
  }

  // Variable globale pour stocker l'observer
  let tomSelectObserver;

  function initializeTomSelectsLazily(forceAll = false) {
    // Si un observer existe, déconnectez-le pour éviter les fuites de mémoire
    // ou si on force l'initialisation de tout le monde, on n'a plus besoin de l'observer.
    if (tomSelectObserver) {
        tomSelectObserver.disconnect();
        tomSelectObserver = null; // Réinitialiser l'observer
    }

    // Ciblez tous les éléments Tom Select potentiels
    const elementsToInitialize = document.querySelectorAll(".note-tags-tomselect");

    if (forceAll) {
        // Initialiser tous les éléments immédiatement, bypassant l'IntersectionObserver
        elementsToInitialize.forEach(el => {
            // Vérifiez si Tom Select n'a pas déjà été initialisé
            if (!el.classList.contains('tomselected') && !el.tomselect) { // Tom Select ajoute 'tomselected' et son instance à 'el.tomselect'
                // --- DÉBUT DU CHANGEMENT ---
                // S'assurer que 'el.value' est une chaîne de caractères pour éviter l'erreur trim() de TomSelect
                if (el.value === undefined || el.value === null) {
                    el.value = '';
                }
                // --- FIN DU CHANGEMENT ---

                const { table, file, index, noteid } = el.dataset;
                const allFileTags = previewDataEdited.tags[file] || [];

                new TomSelect(el, {
                    plugins: {
                        'remove_button': {
                            title: 'Supprimer ce tag'
                        },
                    },
                    create: false,
                    sortField: {field: "$score", direction: "desc"},
                    valueField: 'TagId',
                    labelField: 'Name',
                    searchField: ['Name'],

                    options: allFileTags
                      .filter(tag => tag && typeof tag.TagId === 'number' && typeof tag.Name === 'string') // Filtrez les tags invalides
                      .map(tag => ({ TagId: tag.TagId, Name: tag.Name })),

                    // Maintenez les handlers onItemAdd/onItemRemove ici, ils sont importants pour l'interactivité
                    onItemAdd: function(value) {
                        const newTagId = parseInt(value);
                        if (isNaN(newTagId)) return;
                        const note = previewDataEdited[table][file][index];
                        if (!Array.isArray(note.TagIds)) { note.TagIds = []; }
                        note.TagIds.push(newTagId);
                        note.TagIds = [...new Set(note.TagIds)];
                        invalidateNotesCache();
                        console.log(`[LAZY TS ADD] Tag ${newTagId} ajouté à note [${file}][${index}]. Nouveaux TagIds:`, note.TagIds);
                    },
                    onItemRemove: function(value) {
                        const removedTagId = parseInt(value);
                        if (isNaN(removedTagId)) return;
                        const note = previewDataEdited[table][file][index];
                        if (Array.isArray(note.TagIds)) {
                            note.TagIds = note.TagIds.filter(id => id !== removedTagId);
                        }
                        invalidateNotesCache();
                        console.log(`[LAZY TS REMOVE] Tag ${removedTagId} retiré de note [${file}][${index}]. Nouveaux TagIds:`, note.TagIds);
                    }
                });
            }
        });
    } else {
        // Logique standard d'initialisation paresseuse avec IntersectionObserver
        tomSelectObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                // Si l'élément est visible
                if (entry.isIntersecting) {
                    const el = entry.target;
                    // Vérifiez si Tom Select n'a pas déjà été initialisé
                    if (!el.classList.contains('tomselected') && !el.tomselect) {
                        // --- DÉBUT DU CHANGEMENT ---
                        // S'assurer que 'el.value' est une chaîne de caractères
                        if (el.value === undefined || el.value === null) {
                            el.value = '';
                        }
                        // --- FIN DU CHANGEMENT ---

                        const { table, file, index, noteid } = el.dataset;
                        const allFileTags = previewDataEdited.tags[file] || [];

                        new TomSelect(el, {
                            plugins: {
                                'remove_button': {
                                    title: 'Supprimer ce tag'
                                },
                            },
                            create: false,
                            sortField: {field: "$score", direction: "desc"},
                            valueField: 'TagId',
                            labelField: 'Name',
                            searchField: ['Name'],

                            options: allFileTags
                              .filter(tag => tag && typeof tag.TagId === 'number' && typeof tag.Name === 'string') // Filtrez les tags invalides
                              .map(tag => ({ TagId: tag.TagId, Name: tag.Name })),

                            onItemAdd: function(value) {
                                const newTagId = parseInt(value);
                                if (isNaN(newTagId)) return;
                                const note = previewDataEdited[table][file][index];
                                if (!Array.isArray(note.TagIds)) { note.TagIds = []; }
                                note.TagIds.push(newTagId);
                                note.TagIds = [...new Set(note.TagIds)];
                                invalidateNotesCache();
                                console.log(`[LAZY TS ADD] Tag ${newTagId} ajouté à note [${file}][${index}]. Nouveaux TagIds:`, note.TagIds);
                            },
                            onItemRemove: function(value) {
                                const removedTagId = parseInt(value);
                                if (isNaN(removedTagId)) return;
                                const note = previewDataEdited[table][file][index];
                                if (Array.isArray(note.TagIds)) {
                                    note.TagIds = note.TagIds.filter(id => id !== removedTagId);
                                }
                                invalidateNotesCache();
                                console.log(`[LAZY TS REMOVE] Tag ${removedTagId} retiré de note [${file}][${index}]. Nouveaux TagIds:`, note.TagIds);
                            }
                        });
                    }
                    // Une fois initialisé (ou si déjà initialisé), on n'a plus besoin d'observer cet élément
                    observer.unobserve(el);
                }
            });
        }, {
            root: null, // utilise le viewport comme conteneur racine
            rootMargin: '0px', // ou '200px' pour précharger un peu plus tôt
            threshold: 0.1 // L'élément est considéré comme visible dès que 10% de sa surface est visible
        });

        // Ciblez tous les éléments Tom Select non initialisés pour l'observation
        elementsToInitialize.forEach(el => {
            // S'il n'a pas déjà la classe 'tomselected', cela signifie qu'il n'est pas initialisé
            if (!el.classList.contains('tomselected') && !el.tomselect) {
                tomSelectObserver.observe(el);
            }
        });
    }
  }

  function initializeNoteElements() {
    const tabEl = document.getElementById("tab-notes"); // Récupère l'élément du tableau des notes

    // *** DÉLÉGATION D'ÉVÉNEMENTS pour .editable et .merge-choice ***
    // Un seul écouteur sur tabEl pour les événements 'input'
    tabEl.addEventListener("input", (e) => {
        if (e.target.classList.contains("editable")) {
            const { table, file, index, field } = e.target.dataset;
            if (
                previewDataEdited[table] &&
                previewDataEdited[table][file] &&
                previewDataEdited[table][file][index]
            ) {
                previewDataEdited[table][file][index][field] = e.target.value;
                invalidateNotesCache();
                console.log(`[DELEGATED INPUT] Table: ${table}, File: ${file}, Index: ${index}, Field: ${field}, New Value:`, previewDataEdited[table][file][index][field]);
            }
        }
    });

    // Un seul écouteur sur tabEl pour les événements 'change' (pour les sélecteurs)
    tabEl.addEventListener("change", (e) => {
        if (e.target.classList.contains("merge-choice")) {
            const { table, index } = e.target.dataset;
            if (
                previewDataEdited[table] &&
                previewDataEdited[table].mergeChoices &&
                previewDataEdited[table].mergeChoices[index] !== undefined
            ) {
                previewDataEdited[table].mergeChoices[index] = e.target.value;
                invalidateNotesCache();
                console.log(`[DELEGATED CHANGE] Table: ${table}, Index: ${index}, New Choice:`, previewDataEdited[table].mergeChoices[index]);
            }
        }
    });

    // Logique pour le bouton "Imprimer Notes en PDF" (reste inchangée, car un seul bouton)
    const existingPdfBtn = document.getElementById("exportPdfBtn");
    if (existingPdfBtn) {
        existingPdfBtn.remove(); // Supprimer l'ancien s'il est appelé plusieurs fois
    }
    const btn = document.createElement("button");
    btn.id = "exportPdfBtn";
    btn.textContent = "🖨️ Imprimer Notes en PDF";
    btn.style.margin = "10px 0";
    btn.onclick = exportNotesToPdf; // Assurez-vous que exportNotesToPdf est définie ailleurs
    tabEl.prepend(btn); // Ajoute le bouton en haut du conteneur de l'onglet Notes

    // *** APPEL À L'INITIALISATION PARESSEUSE DE TOM SELECT ***
    initializeTomSelectsLazily();
  }

  function invalidateNotesCache() {
    cachedNotesTabHTML = null;
    notesDataHash = null;
    console.log("Cache de l'onglet Notes invalidé.");
  }

  // ──────────────────────────────────────────────────────────────────────────────
  // Fonction réutilisable pour générer l’onglet Notes
  // ──────────────────────────────────────────────────────────────────────────────
  function buildNotesTab() {
    console.log("buildNotesTab: Démarrage de la reconstruction de l'onglet Notes.");
    const tabEl = document.getElementById("tab-notes");

    // Calculer un hash simple des données des notes
    // C'est une méthode simple pour détecter si les données ont changé.
    // Une méthode plus robuste serait de hacher un JSON.stringify(previewDataEdited.notes)
    // mais ça peut aussi être coûteux. Pour l'instant, on fait simple.
    const currentNotesDataState = JSON.stringify(previewDataEdited.notes);

    // Si le HTML est en cache ET que les données n'ont pas changé, utilisez le cache
    if (cachedNotesTabHTML && notesDataHash === currentNotesDataState) {
        console.log("buildNotesTab: Chargement de l'onglet Notes depuis le cache.");
        tabEl.innerHTML = cachedNotesTabHTML;
        // Important : Ré-initialiser Tom Select et les autres écouteurs même si c'est depuis le cache !
        // Car les éléments DOM ont été recréés par innerHTML
        initializeNoteElements(); // Nouvelle fonction pour regrouper les initialisations
        return; // Sortir de la fonction
    }

    console.log("buildNotesTab: Génération complète de l'onglet Notes.");
    // --- Votre code existant pour générer le HTML ---
    const contents = previewDataEdited.notes;
    const fieldsToKeep = ["Title", "Content"];
    const maxLength = Math.max(contents.file1.length, contents.file2.length);

    const generatedHTML = `
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background-color: #f0f0f0;">
                    <th style="width: 33%; padding: 8px;">📂 Fichier 1</th>
                    <th style="width: 33%; padding: 8px;">📂 Fichier 2</th>
                    <th style="width: 34%; padding: 8px;">✅ Choix</th>
                </tr>
            </thead>
            <tbody>
                ${Array.from({ length: maxLength }).map((_, index) => {
                    const item1 = contents.file1[index] || {};
                    const item2 = contents.file2[index] || {};

                    const html1 = fieldsToKeep.map(field =>
                        renderEditableField("notes", "file1", index, field, item1[field], labels)
                    ).join("");

                    const html2 = fieldsToKeep.map(field =>
                        renderEditableField("notes", "file2", index, field, item2[field], labels)
                    ).join("");

                    return `
                        <tr>
                            <td style="padding: 6px; border: 1px solid #ccc;">${html1}</td>
                            <td style="padding: 6px; border: 1px solid #ccc;">${html2}</td>
                            <td style="padding: 6px; border: 1px solid #ccc;">
                                <select data-table="notes" data-index="${index}" class="merge-choice">
                                    <option value="both">Garder les deux</option>
                                    <option value="file1">Garder fichier 1</option>
                                    <option value="file2">Garder fichier 2</option>
                                    <option value="ignore">Ignorer</option>
                                </select>
                            </td>
                        </tr>`;
                }).join("")}
            </tbody>
        </table>
    `;

    tabEl.innerHTML = generatedHTML; // Insérer le HTML généré

    // Stocker le HTML et le hash pour le caching futur
    cachedNotesTabHTML = generatedHTML;
    notesDataHash = currentNotesDataState;

    // Initialiser tous les éléments interactifs APRÈS que le HTML est dans le DOM
    initializeNoteElements();
  }

  function processLoadedPreviewData(previewData) { // Ancien nom: loadPreviewData
    document.getElementById("preview-section").classList.remove("hidden");
    previewDataEdited = JSON.parse(JSON.stringify(previewData)); // Copie indépendante

    // 🧠 Construire pour chaque fichier une map NoteId → [TagId1, TagId2, ...]
    function buildNoteToTagIdsMap(tagMapArray) {
        const result = {};
        for (const { NoteId, TagId } of tagMapArray || []) {
            if (!result[NoteId]) result[NoteId] = [];
            result[NoteId].push(TagId);
        }
        return result;
    }

    const tagIdsMap1 = buildNoteToTagIdsMap(previewData.tagMaps.file1);
    const tagIdsMap2 = buildNoteToTagIdsMap(previewData.tagMaps.file2);

    // Affecter à chaque note son tableau TagIds
    (previewDataEdited.notes.file1 || []).forEach(note => {
        note.TagIds = tagIdsMap1[note.NoteId] || [];
    });
    (previewDataEdited.notes.file2 || []).forEach(note => {
        note.TagIds = tagIdsMap2[note.NoteId] || [];
    });

    // ──────────────────────────────────────────────────────────────────────────────
    //  INITIALISER previewDataEdited.tagMaps EN GARDANT DES TABLEAUX
    // ──────────────────────────────────────────────────────────────────────────────
    previewDataEdited.tagMaps = {
        file1: (previewData.tagMaps.file1 || []).map(tm => ({ ...tm })),
        file2: (previewData.tagMaps.file2 || []).map(tm => ({ ...tm }))
    };

    // ──────────────────────────────────────────────────────────────────────────────
    //  CONSTRUIRE previewDataEdited.tags.list PAR FICHIER
    // ──────────────────────────────────────────────────────────────────────────────
    previewDataEdited.tags = {
        file1: [],
        file2: []
    };

    const seen1 = new Set();
    (previewData.tags.file1 || []).forEach(t => {
        if (!seen1.has(t.TagId)) {
            previewDataEdited.tags.file1.push({ TagId: t.TagId, Name: t.Name });
            seen1.add(t.TagId);
        }
    });

    const seen2 = new Set();
    (previewData.tags.file2 || []).forEach(t => {
        if (!seen2.has(t.TagId)) {
            previewDataEdited.tags.file2.push({ TagId: t.TagId, Name: t.Name });
            seen2.add(t.TagId);
        }
    });

    // fieldFilter et labels sont maintenant globaux, vous pouvez retirer leur déclaration d'ici
    // const fieldFilter = { /* ... */ };
    // const labels = { /* ... */ };

    // --- NOUVEAUX APPELS POUR LES AUTRES ONGLET ---

    // Une fois que previewDataEdited est COMPLÈTEMENT prêt:
    invalidateNotesCache(); // Invalider le cache des notes pour forcer la première construction
    window.refreshNotesTab(); // Appeler le rafraîchissement de l'onglet Notes (qui gère l'affichage)

    // AFFICHER LES AUTRES ONGLETs APRÈS AVOIR CHARGÉ LES DONNÉES
    // Ceci appellera showTab('bookmarks') qui à son tour construira l'onglet Bookmarks
    // et showTab('tags') pour l'onglet Tags.
    // L'ordre ici peut être ajusté si vous voulez qu'un onglet particulier soit affiché par défaut.
    // Par exemple, si vous voulez que Bookmarks soit le premier affiché après le chargement:
    // showTab('bookmarks'); // Ceci devrait être le tab par défaut après le chargement
    // Puis l'utilisateur peut cliquer sur Notes ou Tags.

    // Si vous voulez que l'onglet Notes soit le premier affiché, l'appel à window.refreshNotesTab() au-dessus suffit.
    // Les appels showTab suivants sont pour s'assurer qu'ils sont prêts pour le clic utilisateur.
    // Vous pouvez commenter ces lignes si le HTML des onglets bookmarks/tags est déjà généré
    // une fois et n'a pas besoin d'être re-généré au premier affichage.

    // La logique de génération des autres onglets (bookmarks et tags) est déjà dans le bloc
    // `for (const tableName of ["bookmarks", "tags"]) { ... }` que vous avez.
    // Il faut juste s'assurer qu'il est exécuté.
    // Au lieu d'appeler showTab directement, assurons-nous que ce bloc s'exécute.

    // ──────────────────────────────────────────────────────────────────────────────
    // Rendu des autres onglets : Bookmarks et Tags (si cette logique est encore dans loadPreviewData)
    // ──────────────────────────────────────────────────────────────────────────────
    for (const tableName of ["bookmarks", "tags"]) {
      const contents = previewDataEdited[tableName]; // Utilisez previewDataEdited
      const tabEl = document.getElementById(`tab-${tableName.toLowerCase()}`);
      if (!contents || !Array.isArray(contents.file1) || !Array.isArray(contents.file2)) continue;

      const fieldsToKeep = fieldFilter[tableName.toLowerCase()] || []; // Assurez-vous que fieldFilter est global

      const maxLength = Math.max(contents.file1.length, contents.file2.length);

      tabEl.innerHTML = `
        <table style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr style="background-color: #f0f0f0;">
              <th style="width: 33%; padding: 8px;">📂 Fichier 1</th>
              <th style="width: 33%; padding: 8px;">📂 Fichier 2</th>
              <th style="width: 34%; padding: 8px;">✅ Choix</th>
            </tr>
          </thead>
          <tbody>
            ${Array.from({ length: maxLength }).map((_, index) => {
              const item1 = contents.file1[index] || {};
              const item2 = contents.file2[index] || {};

              const html1 = fieldsToKeep.map(field =>
                renderEditableField(tableName.toLowerCase(), "file1", index, field, item1[field], labels)
              ).join("");

              const html2 = fieldsToKeep.map(field =>
                renderEditableField(tableName.toLowerCase(), "file2", index, field, item2[field], labels)
              ).join("");

              return `
                <tr>
                  <td style="padding: 6px; border: 1px solid #ccc;">${html1}</td>
                  <td style="padding: 6px; border: 1px solid #ccc;">${html2}</td>
                  <td style="padding: 6px; border: 1px solid #ccc;">
                    <select data-table="${tableName}" data-index="${index}" class="merge-choice">
                      <option value="both">Garder les deux</option>
                      <option value="file1">Garder fichier 1</option>
                      <option value="file2">Garder fichier 2</option>
                      <option value="ignore">Ignorer</option>
                    </select>
                  </td>
                </tr>`;
            }).join("")}
          </tbody>
        </table>
      `;
      // Attacher les écouteurs pour les champs éditables des autres onglets
      tabEl.querySelectorAll(".editable").forEach((el) => {
        el.addEventListener("input", (e) => {
          const { table, file, index, field } = e.target.dataset;
          if (
            previewDataEdited[table] &&
            previewDataEdited[table][file] &&
            previewDataEdited[table][file][index]
          ) {
            previewDataEdited[table][file][index][field] = e.target.value;
            console.log(`[EDITABLE INPUT - OTHER TABS] Table: ${table}, File: ${file}, Index: ${index}, Field: ${field}, New Value:`, previewDataEdited[table][file][index][field]);
          }
        });
      });
      // Si les autres onglets ont des Tom Select, ils devraient aussi avoir une fonction initializeOtherTabElements()
      // comme initializeNoteElements()
    }
  }

  function showFullNote(content) {
    document.getElementById("noteModalText").textContent = event.target.previousElementSibling?.value || content;
    document.getElementById("noteModal").style.display = "flex";
  }

  document.getElementById("noteModalClose").onclick = () => {
    document.getElementById("noteModal").style.display = "none";
  };

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      document.getElementById("noteModal").style.display = "none";
    }
  });

  // 🔴 Ajout : fermeture en cliquant à l'extérieur du contenu
  document.getElementById("noteModal").addEventListener("click", (e) => {
    const content = document.querySelector(".note-modal-content");
    if (!content.contains(e.target)) {
      document.getElementById("noteModal").style.display = "none";
    }
  });

  async function startPreparation() {
    try {
      const file1 = document.getElementById('file1').files[0];
      const file2 = document.getElementById('file2').files[0];
      const localDatetime = document.getElementById('local_datetime').value;

      if (!file1 || !file2)
        throw new Error(translations[window.currentLang].errors.selectFiles);
      if (!file1.name.endsWith('.jwlibrary') || !file2.name.endsWith('.jwlibrary'))
        throw new Error(translations[window.currentLang].errors.extension);
      if (!localDatetime)
        throw new Error(translations[window.currentLang].errors.missingDate);

      const mergeButton = document.getElementById('mergeButton');
      mergeButton.disabled = true;

      await updateProgress(5, "Préparation des fichiers...", 1);
      await simulateProcessing(800, 15, "Chargement des fichiers...", 1);

      const zip1 = await JSZip.loadAsync(file1);
      const zip2 = await JSZip.loadAsync(file2);

      const userData1 = await zip1.file("userData.db").async("blob");
      const userData2 = await zip2.file("userData.db").async("blob");

      const maxCombinedSize = 95 * 1024 * 1024;
      if (userData1.size + userData2.size > maxCombinedSize) {
        throw new Error("Les fichiers userData.db sont trop volumineux (plus de 95MB combinés).");
      }

      const media1 = [], media2 = [];

      const hashFile = async (file) => {
        const buffer = await file.async("arraybuffer");
        const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
        return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
      };

      const collectMedia = async (zip, targetList, skip = ["userData.db", "userData.db-shm", "userData.db-wal"]) => {
        const skipSet = new Set(skip.map(s => s.toLowerCase()));
        for (const file of Object.values(zip.files)) {
          if (skipSet.has(file.name.toLowerCase())) continue;
          const hash = await hashFile(file);
          targetList.push({ name: file.name, file, hash });
        }
      };

      await collectMedia(zip1, media1);
      await collectMedia(zip2, media2);

      const hashSet1 = new Set(media1.map(m => m.hash));
      const uniqueMedia2 = media2.filter(m => !hashSet1.has(m.hash));
      const combinedMedia = [...media1, ...uniqueMedia2];

      window.mediaToInclude = await Promise.all(
        combinedMedia.map(async (media) => ({
          name: media.name,
          file: await media.file.async("blob"),
          hash: media.hash
        }))
      );

      window.userData1 = userData1;
      window.userData2 = userData2;

      const formData = new FormData();
      formData.append("file1", new File([userData1], "userData1.db"));
      formData.append("file2", new File([userData2], "userData2.db"));

      await updateProgress(20, "Téléversement...", 2);
      await uploadWithProgress(`${BASE_URL}/upload`, formData);

      await updateProgress(60, "Préparation de l'aperçu...", 3);
      const previewRes = await fetch(`${BASE_URL}/prepare-preview`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ local_datetime: localDatetime })
      });

      if (!previewRes.ok) {
        const text = await previewRes.text();
        throw new Error("Erreur dans la préparation : " + text);
      }

      const previewData = await previewRes.json();

      // --- DÉBUT DES MODIFICATIONS POUR LA PHASE 4 ---

      // La barre atteint un point de départ visuel pour la phase 4.
      // Le travail de génération du DOM commence APRÈS cette ligne.
      await updateProgress(85, "Génération de la prévisualisation dans le navigateur...", 4);

      // Enregistrez le temps AVANT le travail lourd de JS
      const startProcessingTime = performance.now();

      console.log("📦 Données reçues pour l’aperçu :", previewData);

      // Sécurité : affichage des clés attendues
      console.log("🔍 Aperçu .notes :", previewData.notes);
      console.log("🔍 Aperçu .bookmarks :", previewData.bookmarks);
      console.log("🔍 Aperçu .tags :", previewData.tags);
      console.log("🔍 Aperçu .tagMaps :", {
        file1: previewData.tagMaps.file1.length,
        file2: previewData.tagMaps.file2.length
      });

      // Empêche l’erreur si previewData.notes est undefined
      if (!previewData.notes || !Array.isArray(previewData.notes.file1) || !Array.isArray(previewData.notes.file2)) {
        console.error("❌ 'notes.file1' ou 'notes.file2' manquant ou invalide dans le JSON reçu.");
        throw new Error("Le backend n’a pas renvoyé la structure attendue pour les notes.");
      }

      // Exécutez le traitement lourd de génération des onglets
      // Ceci inclut la création du HTML et le premier appel à refreshNotesTab
      processLoadedPreviewData(previewData);

      // Enregistrez le temps APRÈS le travail lourd de JS
      const endProcessingTime = performance.now();
      const actualProcessingDuration = endProcessingTime - startProcessingTime;

      // Définissons une durée minimale pour que l'animation de la barre ait le temps de s'afficher.
      // C'est la durée que la barre doit au moins prendre pour passer de 85% à 95%.
      const minAnimationDurationForPhase4 = 3000; // Par exemple, 3 secondes

      // Calculez combien de temps il reste à "simuler" si le traitement réel a été trop rapide.
      // Si le traitement réel a pris 8-10 secondes, remainingSimulationDuration sera 0.
      const remainingSimulationDuration = Math.max(0, minAnimationDurationForPhase4 - actualProcessingDuration);

      // Simule la progression de 85% à 95% sur la durée restante calculée.
      // Le message change pour indiquer que l'affichage est en cours.
      await simulateProcessing(remainingSimulationDuration, 95, "Affichage des données dans les onglets...", 4);

      // --- FIN DES MODIFICATIONS POUR LA PHASE 4 ---

      await updateProgress(100, "Aperçu prêt", 5);
      document.getElementById('merge-summary').classList.remove('hidden');
      document.getElementById("progressDetails").textContent = "✅ Prévisualisation terminée.";
    } catch (error) {
      console.error("Erreur:", error);
      showError(error.message);
      await logMergeToSupabase("error", error.message);
      await updateProgress(currentProgress, `Erreur: ${error.message}`);
      document.getElementById('mergeButton').disabled = false;
    }
  }

  async function exportNotesToPdf() {
    const { jsPDF } = window.jspdf;
    const file1Notes = previewDataEdited.notes?.file1 || [];
    const file2Notes = previewDataEdited.notes?.file2 || [];

    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    const fontSize = 8;
    const lineHeight = fontSize * 0.35;
    const espaceEntreTitreEtTexte = 2;
    let yPosition = 30;

    const addText = (text, x, y, maxWidth) => {
      const lines = doc.splitTextToSize(text, maxWidth);
      if (x > 0 && y > 0) {
        doc.text(lines, x, y);
      }
      return lines.length * lineHeight;
    };

    doc.setFontSize(16);
    doc.text('Notes totales des 2 fichiers', 105, yPosition, { align: 'center' });
    doc.setFontSize(fontSize);
    yPosition += 12;

    const now = new Date();
    const dateStr = now.toLocaleDateString('fr-FR') + ' ' + now.toLocaleTimeString('fr-FR');
    doc.text(`Fichier 1 : ${file1Notes.length} notes`, 15, yPosition);
    doc.text(`Fichier 2 : ${file2Notes.length} notes`, 105, yPosition);
    doc.text(`Date : ${dateStr}`, 15, yPosition + 7);
    yPosition += 17;

    doc.setFont(undefined, 'bold');
    doc.text('Fichier 1', 30, yPosition);
    doc.text('Fichier 2', 120, yPosition);
    doc.setFont(undefined, 'normal');
    yPosition += 5;

    doc.line(15, yPosition, 195, yPosition);
    yPosition += 5;

    const maxLength = Math.max(file1Notes.length, file2Notes.length);

    for (let i = 0; i < maxLength; i++) {
      const note1 = file1Notes[i] || {};
      const note2 = file2Notes[i] || {};

      const title1 = note1.Title || 'Sans titre';
      const content1 = note1.Content || '';
      const title2 = note2.Title || 'Sans titre';
      const content2 = note2.Content || '';

      // Préparer toutes les lignes de chaque colonne
      const lignesTitle1 = doc.splitTextToSize(title1, 80);
      const lignesContent1 = doc.splitTextToSize(content1, 80);
      const lignes1 = [...lignesTitle1, ...Array(1).fill(''), ...lignesContent1];

      const lignesTitle2 = doc.splitTextToSize(title2, 80);
      const lignesContent2 = doc.splitTextToSize(content2, 80);
      const lignes2 = [...lignesTitle2, ...Array(1).fill(''), ...lignesContent2];

      const espaceEntreTitreEtTexte = 2;
      const hauteurLigne = lineHeight; // hauteur fixe par ligne

      // On va itérer ligne par ligne, en coupant si nécessaire
      const maxLignes = Math.max(lignes1.length, lignes2.length);
      for (let j = 0; j < maxLignes; j++) {
        // Avant d'imprimer la prochaine ligne, vérifier si la page est pleine
        if (yPosition + hauteurLigne > 280) {
          doc.addPage();
          yPosition = 20;
        }

        // Imprimer la j-ième ligne de la colonne 1, si elle existe
        if (j < lignes1.length) {
          if (j < lignesTitle1.length) {
            doc.setFont(undefined, 'bold');
          } else {
            doc.setFont(undefined, 'normal');
          }
          doc.text(lignes1[j], 30, yPosition);
        }

        // Imprimer la j-ième ligne de la colonne 2, si elle existe
        if (j < lignes2.length) {
          if (j < lignesTitle2.length) {
            doc.setFont(undefined, 'bold');
          } else {
            doc.setFont(undefined, 'normal');
          }
          doc.text(lignes2[j], 120, yPosition);
        }

        yPosition += hauteurLigne;
      }

      // Après avoir imprimé toutes les lignes de la note, tracer la séparation
      if (yPosition + 5 > 280) {
        doc.addPage();
        yPosition = 20;
      }
      doc.setFont(undefined, 'normal');
      doc.line(15, yPosition, 195, yPosition);
      yPosition += 8;
    }


    doc.save('notes.pdf');
  }

  window.refreshNotesTab = function() {
    return new Promise((resolve) => {
      const startAnimationTime = Date.now();
      setTimeout(() => {
        buildNotesTab();
        const elapsedBuildTime = Date.now() - startAnimationTime;
        const remainingTime = MIN_LOAD_TIME_MS - elapsedBuildTime;
        if (remainingTime > 0) {
          setTimeout(() => {
            resolve();
          }, remainingTime);
        } else {
          resolve();
        }
      }, 0);
    });
  };

  async function showTab(tabName) {
    // Masquer tous les contenus
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.add('hidden');
    });

    // Trouver le bouton cliqué
    const clickedBtn = Array.from(document.querySelectorAll('.tab-btn')).find(btn =>
        btn.textContent.toLowerCase().includes(tabName)
    );

    // Réinitialiser tous les boutons sauf celui cliqué
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
        const progressBar = btn.querySelector('.progress-bar');
        if (progressBar && btn !== clickedBtn) {
            progressBar.style.width = '0%';
            progressBar.style.transition = 'none';
        }
    });

    // Activer le bouton cliqué et démarrer la barre
    if (clickedBtn) {
        clickedBtn.classList.add('active');
        clickedBtn.dataset.tabName = tabName;
        startProgressBarAnimation(clickedBtn, tabName);
    }

    // Afficher le contenu cible
    const targetTabContent = document.getElementById(`tab-${tabName}`);
    if (targetTabContent) {
        targetTabContent.classList.remove('hidden');
    }

    try {
        // Gérer le chargement spécifique à chaque onglet
        switch (tabName) {
            case "notes":
                if (typeof window.refreshNotesTab === "function") {
                    await window.refreshNotesTab(); // Attendre la fin du chargement
                } else {
                    console.warn("ShowTab: window.refreshNotesTab n'est pas une fonction.");
                }
                break;

            case "bookmarks":
            case "tags":
                console.log(`ShowTab: Onglet ${tabName} sélectionné.`);
                // Simuler un temps de chargement minimal
                await new Promise(resolve => setTimeout(resolve, 500));
                break;
        }
    } catch (error) {
        console.error("Erreur lors du chargement de l'onglet:", error);
    } finally {
        // Terminer l'animation une fois tout le chargement terminé
        if (clickedBtn) {
            finishProgressBarAnimation(clickedBtn, tabName);
        }
    }
  }

  document.addEventListener("click", function (e) {
    if (e.target.classList.contains("show-full-note")) {
      e.preventDefault();
      const content = e.target.getAttribute("data-content");
      const label = e.target.getAttribute("data-label");
      showFullNote(content, label);
    }
  });

  function renderNotesPreview(data) {
    const tbody = document.getElementById("notes-preview-body");
    tbody.innerHTML = "";

    data.forEach((conflict, index) => {
      const row = document.createElement("tr");

      const td1 = document.createElement("td");
      td1.textContent = conflict.file1?.content || "";
      row.appendChild(td1);

      const td2 = document.createElement("td");
      td2.textContent = conflict.file2?.content || "";
      row.appendChild(td2);

      const tdChoice = document.createElement("td");
      ["file1", "file2", "merge"].forEach(choice => {
        const label = document.createElement("label");
        label.style.marginRight = "10px";

        const radio = document.createElement("input");
        radio.type = "radio";
        radio.name = `note-choice-${index}`;
        radio.value = choice;
        if (choice === "merge") radio.checked = true;

        label.appendChild(radio);
        label.appendChild(document.createTextNode(" " + choice));
        tdChoice.appendChild(label);
      });

      row.appendChild(tdChoice);
      tbody.appendChild(row);
    });
  }

  function updateMergeSteps(activeIndex) {
    for (let i = 1; i <= 5; i++) {
      const step = document.getElementById(`mergeStep${i}`);
      if (i < activeIndex) {
        step.classList.add('completed');
        step.classList.remove('active');
      } else if (i === activeIndex) {
        step.classList.add('active');
        step.classList.remove('completed');
      } else {
        step.classList.remove('active', 'completed');
      }
    }
  }

  async function startMerge() {
    try {
      const file1 = document.getElementById('file1').files[0];
      const file2 = document.getElementById('file2').files[0];
      let localDatetime = document.getElementById('local_datetime').value;

      if (!localDatetime) {
          const now = new Date();
          const year = now.getFullYear();
          const month = String(now.getMonth() + 1).padStart(2, '0');
          const day = String(now.getDate()).padStart(2, '0');
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          localDatetime = `${year}-${month}-${day}T${hours}:${minutes}`;
      }

      if (!file1 || !file2)
        throw new Error(translations[window.currentLang].errors.selectFiles);
      if (!file1.name.endsWith('.jwlibrary') || !file2.name.endsWith('.jwlibrary'))
        throw new Error(translations[window.currentLang].errors.extension);
      if (!localDatetime)
        throw new Error(translations[window.currentLang].errors.missingDate);

      const mergeButton = document.getElementById('mergeButton');
      mergeButton.disabled = true;

      updateMergeSteps(1);
      await updateProgress(5, "Préparation des fichiers...", 1);
      await simulateProcessing(800, 20, "Chargement des fichiers...", 1);

      const zip1 = await JSZip.loadAsync(file1);
      const zip2 = await JSZip.loadAsync(file2);

      const userData1 = await zip1.file("userData.db").async("blob");
      const userData2 = await zip2.file("userData.db").async("blob");

      const maxCombinedSize = 95 * 1024 * 1024;
      if (userData1.size + userData2.size > maxCombinedSize) {
        throw new Error("Les fichiers userData.db sont trop volumineux (plus de 95MB combinés).");
      }

      const media1 = [], media2 = [];
      const hashFile = async (file) => {
        const buffer = await file.async("arraybuffer");
        const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
        return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
      };

      const collectMedia = async (zip, targetList, skip = ["userData.db", "userData.db-shm", "userData.db-wal"]) => {
        const skipSet = new Set(skip.map(n => n.toLowerCase()));
        for (const file of Object.values(zip.files)) {
          const name = file.name.toLowerCase();
          if ([...skipSet].some(skip => name.endsWith(skip))) continue;
          const hash = await hashFile(file);
          targetList.push({ name: file.name, file, hash });
        }
      };

      await collectMedia(zip1, media1);
      await collectMedia(zip2, media2);

      const hashSet1 = new Set(media1.map(m => m.hash));
      const uniqueMedia2 = media2.filter(m => !hashSet1.has(m.hash));
      const combinedMedia = [...media1, ...uniqueMedia2];

      window.mediaToInclude = await Promise.all(
        combinedMedia.map(async (media) => ({
          name: media.name,
          file: await media.file.async("blob"),
          hash: media.hash
        }))
      );

      window.userData1 = userData1;
      window.userData2 = userData2;

      const formData = new FormData();
      formData.append("file1", new File([userData1], "userData1.db"));
      formData.append("file2", new File([userData2], "userData2.db"));

      updateMergeSteps(2);
      await updateProgress(20, "Début de l'upload...", 2);
      await uploadWithProgress(`${BASE_URL}/upload`, formData);

      await updateProgress(50, "Extraction des données...", 3);
      await simulateProcessing(3000, 80, "Analyse des contenus...", 3);

      updateMergeSteps(3);
      await updateProgress(90, "Fusion en cours...", 4);
      appendToMergeLog("Fusion en cours, veuillez patienter...");

      const progressBar = document.getElementById('progressBar');
      progressBar.classList.add('progress-bar-animated');
      document.getElementById('construction-container').classList.remove('hidden');

      console.log("DEBUG: previewDataEdited.tags AVANT TomSelect init:", previewDataEdited.tags);
      // NOUVEAU : Forcer l'initialisation de TOUS les Tom Selects, visibles ou non.
      initializeTomSelectsLazily(true);

      const choices = { notes: {}, bookmarks: {}, tags: {} };
      document.querySelectorAll(".merge-choice").forEach(select => {
        const table = select.dataset.table;
        const index = select.dataset.index;
        const value = select.value;

        if (!choices[table]) choices[table] = {};
        if (!choices[table][index]) choices[table][index] = {};

        choices[table][index].choice = value;

        const editedFile1 = previewDataEdited[table]?.file1?.[index] || {};
        const editedFile2 = previewDataEdited[table]?.file2?.[index] || {};
        choices[table][index].edited = {
          file1: editedFile1,
          file2: editedFile2
        };

        if (table === "notes") {
          const collectedTagIdsFile1 = [];
          const collectedTagIdsFile2 = [];

          // Le sélecteur est bien '.note-tags-tomselect'
          // Et maintenant, l'instance devrait être présente grâce à l'initialisation forcée.
          document.querySelectorAll(`.note-tags-tomselect[data-index="${index}"]`).forEach(selectElement => {
              const tomSelectInstance = selectElement.tomselect;

              if (tomSelectInstance) {
                  const selectedValues = tomSelectInstance.getValue();
                  const tagIdsForThisSelect = Array.isArray(selectedValues) ?
                      selectedValues.map(id => parseInt(id)).filter(id => !isNaN(id) && id !== 0) :
                      (selectedValues ? [parseInt(selectedValues)].filter(id => !isNaN(id) && id !== 0) : []);

                  const sourceFile = selectElement.dataset.file;

                  if (sourceFile === 'file1') {
                      collectedTagIdsFile1.push(...tagIdsForThisSelect);
                  } else if (sourceFile === 'file2') {
                      collectedTagIdsFile2.push(...tagIdsForThisSelect);
                  }
              } else {
                  // Ce message d'avertissement NE DEVRAIT PLUS apparaître si l'initialisation forcée a fonctionné correctement.
                  console.warn(`Tom Select instance non trouvée pour l'élément avec data-index="${index}" et data-file="${selectElement.dataset.file}". (APRES INITIALISATION FORCEE)`);
              }
          });

          const noteObj1 = previewDataEdited.notes.file1?.[index];
          const noteObj2 = previewDataEdited.notes.file2?.[index];
          const noteId1 = noteObj1?.NoteId;
          const noteId2 = noteObj2?.NoteId;

          if (!choices[table][index].noteIds) choices[table][index].noteIds = {};
          if (noteId1) choices[table][index].noteIds.file1 = noteId1;
          if (noteId2) choices[table][index].noteIds.file2 = noteId2;

          const choice = value;

          if (choice === "both") {
              const merged = [...new Set([...collectedTagIdsFile1, ...collectedTagIdsFile2])];
              choices[table][index].selectedTags = merged;
          } else {
              if (!choices[table][index].selectedTagsPerSource)
                  choices[table][index].selectedTagsPerSource = {};
              choices[table][index].selectedTagsPerSource[choice] =
                  choice === "file1" ? collectedTagIdsFile1 : collectedTagIdsFile2;
          }
        }

        if (table === "bookmarks") {
          const bookmarkObj1 = previewDataEdited.bookmarks.file1?.[index];
          const bookmarkObj2 = previewDataEdited.bookmarks.file2?.[index];
          const bookmarkId1 = bookmarkObj1?.BookmarkId;
          const bookmarkId2 = bookmarkObj2?.BookmarkId;

          if (!choices.bookmarks[index].bookmarkIds) choices.bookmarks[index].bookmarkIds = {};
          if (bookmarkId1) choices.bookmarks[index].bookmarkIds.file1 = bookmarkId1;
          if (bookmarkId2) choices.bookmarks[index].bookmarkIds.file2 = bookmarkId2;
        }
      });

      console.log("🚀 PAYLOAD ENVOYÉ DEPUIS LE FRONTEND:", JSON.stringify({ local_datetime, choices }, null, 2));

      const response = await fetch(`${BASE_URL}/merge`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "ngrok-skip-browser-warning": "true"
        },
        body: JSON.stringify({
          local_datetime: localDatetime,
          choices: choices
        })
      });

      console.log("Données envoyées:", JSON.stringify({ local_datetime, choices }, null, 2));

      if (!response.ok) {
        const errorText = await response.text();
        showError(errorText || translations[window.currentLang].errors.mergeFailed);
        throw new Error("Erreur backend : " + errorText);
      }

      const result = await response.json();
      if (result.merge_status !== "done") {
        throw new Error("La fusion n’a pas été finalisée correctement.");
      }

      progressBar.classList.remove('progress-bar-animated');
      document.getElementById('construction-container').classList.add('hidden');

      updateMergeSteps(4);
      await updateProgress(92, "Création du fichier ZIP final...", 5);
      await updateProgress(95, "Reconstruction du fichier .jwlibrary...", 5);

      await rebuildFinalZip();
      trackMerge("success");
      await logMergeToSupabase("success");

      updateMergeSteps(5);
      await updateProgress(100, "Fichier prêt", 5);
      document.getElementById("progressDetails").textContent = "✅ Téléchargement terminé ou en cours.";

      const step5 = document.getElementById("step5");
      step5.classList.remove("active");
      step5.classList.add("completed");

      document.getElementById('merge-summary').classList.remove('hidden');
      document.getElementById('summary-text').innerHTML =
        `La fusion est terminée. Les données identiques (notes, surlignages, marques-pages, playlists, etc.) ont été conservées.
        Les éléments uniques de chaque fichier ont été ajoutés.<br><br>
        <strong>💡 Une fois le téléchargement automatique effectué, tous les fichiers sont immédiatement effacés. Si le téléchargement ne s'est pas bien passé, actualise la page et renouvelle l'opération en entier.</strong>`;
    } catch (error) {
      console.error("Erreur:", error);
      showError(error.message);
      trackMerge("error", error.message);
      await logMergeToSupabase("error", error.message);
      await updateProgress(currentProgress, `Erreur: ${error.message}`);
      document.getElementById('mergeButton').disabled = false;
    }
  }


  function renderPreviewTabs(data) {
    const tabs = Object.keys(data); // ["notes", "bookmarks", "tags"]
    const tabButtons = document.getElementById("tab-buttons");
    const tabContents = document.getElementById("tab-contents");

    tabButtons.innerHTML = "";
    tabContents.innerHTML = "";

    tabs.forEach((tabName, index) => {
      const btn = document.createElement("button");
      btn.className = "tab-button";
      btn.textContent = tabName;
      if (index === 0) btn.classList.add("active");
      btn.onclick = () => switchPreviewTab(tabName);
      tabButtons.appendChild(btn);

      const tabDiv = document.createElement("div");
      tabDiv.id = `tab-${tabName}`;
      tabDiv.className = "tab-content" + (index === 0 ? " active" : "");

      const table = document.createElement("table");
      table.className = "diff-table";
      table.innerHTML = `
        <thead><tr><th>Fichier 1</th><th>Fichier 2</th><th>Fusionné</th></tr></thead>
        <tbody>
          ${data[tabName].map(row => `
            <tr>
              <td class="${isDiff(row) ? 'highlight' : ''}">${format(row.file1)}</td>
              <td class="${isDiff(row) ? 'highlight' : ''}">${format(row.file2)}</td>
              <td>${format(row.merged)}</td>
            </tr>
          `).join("")}
        </tbody>
      `;
      tabDiv.appendChild(table);
      tabContents.appendChild(tabDiv);
    });
  }

  function isDiff(row) {
    return JSON.stringify(row.file1 || {}) !== JSON.stringify(row.file2 || {});
  }

  function format(obj) {
    if (!obj) return "<i>null</i>";
    return Object.entries(obj).map(([k, v]) => `<b>${k}</b>: ${v}`).join("<br>");
  }

  function switchPreviewTab(tabName) {
    document.querySelectorAll(".tab-button").forEach(btn => {
      btn.classList.toggle("active", btn.textContent === tabName);
    });
    document.querySelectorAll(".tab-content").forEach(div => {
      div.classList.toggle("active", div.id === `tab-${tabName}`);
    });
  }

  function trackMerge(status, message = null) {
    const payload = { status };
    if (status === "error" && message) {
      payload.message = message;
    }

    fetch(`${BASE_URL}/track-merge`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    }).then(res => {
      if (!res.ok) console.warn("❌ Erreur d'envoi des stats de fusion");
    }).catch(err => {
      console.warn("❌ Erreur réseau pour les stats :", err);
    });
  }

  async function rebuildFinalZip() {
    try {
      console.log("📥 " + translations[window.currentLang].messages.downloadingFiles);

      const isAppleDevice = /iPad|iPhone|iPod/.test(navigator.userAgent);
      if (isAppleDevice) {
        const manualContainer = document.getElementById("manualDownloadContainer");
        const manualMessage = document.getElementById("manualDownloadMessage");
        const manualBtn = document.getElementById("manualDownloadBtn");

        manualContainer.classList.remove("hidden");
        manualMessage.textContent = translations[window.currentLang].messages.preparingDownload;
        manualBtn.textContent = translations[window.currentLang].actions.manualDownload;
      }

      const fetchFile = async (name) => {
        const res = await fetch(`${BASE_URL}/download/${name}?ngrok-skip-browser-warning=true`);
        if (!res.ok) throw new Error(`${translations[window.currentLang].errors.fetchError} ${name}`);
        return await res.blob();
      };

      const [debugBlob, shmBlob, walBlob] = await Promise.all([
        fetchFile("debug_cleaned_before_copy.db"),
        fetchFile("debug_cleaned_before_copy.db-shm"),
        fetchFile("debug_cleaned_before_copy.db-wal")
      ]);

      console.log("✅ " + translations[window.currentLang].messages.filesDownloaded);

      const zip = new JSZip();
      zip.file("userData.db", debugBlob, { binary: true, compression: "DEFLATE" });
      zip.file("userData.db-shm", shmBlob, { binary: true, compression: "DEFLATE" });
      zip.file("userData.db-wal", walBlob, { binary: true, compression: "DEFLATE" });

      if (window.mediaToInclude?.length) {
        for (const media of window.mediaToInclude) {
          zip.file(media.name, media.file, { binary: true, compression: "DEFLATE" });
        }
      }

      console.log("📦 " + translations[window.currentLang].messages.creatingArchive);

      const finalZip = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: { level: isAppleDevice ? 6 : 9 }
      });

      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const filename = `UserdataBackup_${yyyy}-${mm}-${dd}_merged.jwlibrary`;

      window.generatedZipBlob = finalZip;
      window.generatedFilename = filename;

      if (!isAppleDevice) {
        // Téléchargement automatique pour les autres plateformes
        const zipUrl = URL.createObjectURL(finalZip);
        const link = document.createElement("a");
        link.href = zipUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        setTimeout(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(zipUrl);
        }, 100);
        console.log("🎯 " + translations[window.currentLang].messages.autoDownloadStarted);
      } else {
        // Pour iOS, on s'assure que le bouton manuel est configuré
        const manualBtn = document.getElementById("manualDownloadBtn");
        manualBtn.onclick = () => {
          const manualUrl = URL.createObjectURL(finalZip);
          const manualLink = document.createElement("a");
          manualLink.href = manualUrl;
          manualLink.download = filename;
          document.body.appendChild(manualLink);
          manualLink.click();
          setTimeout(() => {
            document.body.removeChild(manualLink);
            URL.revokeObjectURL(manualUrl);
          }, 3000);
        };
      }

    } catch (error) {
      console.error("❌ " + translations[window.currentLang].errors.operationFailed, error);

      if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
        const manualMessage = document.getElementById("manualDownloadMessage");
        if (manualMessage) {
          manualMessage.textContent = `${translations[window.currentLang].errors.operationFailed}: ${error.message}`;
          manualMessage.style.color = "#f44336";
        }
      }
    }
  }

  const translations = {
    fr: {
      title: "Fusionner des fichiers JW Library",
      file1: "Sélectionner le premier fichier (.jwlibrary) :",
      file2: "Sélectionner le deuxième fichier (.jwlibrary) :",
      datetime: "Date et heure locales actuelles :",
      steps: ["Chargement", "Extraction", "Analyse", "Détection", "Prêt..."],
      mergeButton: "Charger, Extraire & Analyser",
      summary: `La prévisualisation est prête. Pour bien comprendre : Ce que tu vas voir ci-dessous, ce sont uniquement les notes, les marque-pages et les catégories de la base de donnée JWlibrary.
  De base, sans aucun changement, le programme analyse tout seul et, si 2 notes ou 2 marque-pages ou 2 catégories sont différents, le programme garde les 2. Si tu as 2 notes, 2 marque-pages ou 2 catégories identiques, le programme ne va en garder qu'un.<br><br>
  Tu peux faire certains changements qui seront pris en compte lors de la fusion comme par exemple Modifier ou supprimer une note personnelle, modifier ou supprimer un marque-pages ou une catégorie.
  <strong>💡 Si tu ne veux faire aucun changements, appuie sur le bouton ci-dessous: LANCER LA FUSION FINALE. Si tu veux faire des changements, tu peux les faire puis appuyer sur LANCER LA FUSION FINALE.</strong>`,
      progressReady: "Prêt à commencer...",
      final: "✅ Téléchargement terminé ou en cours.",
      errors: {
        selectFiles: "Veuillez sélectionner deux fichiers .jwlibrary",
        extension: "Les deux fichiers doivent avoir l'extension .jwlibrary",
        missingDate: "Veuillez indiquer la date et l'heure locales actuelles",
        mergeFailed: "La fusion n’a pas été finalisée correctement.",
        fetchError: "Erreur lors du téléchargement de"
      },
      footer: {
        message: `Ce site est complètement gratuit comme tout ce que fait l'organisation de Jéhovah.<br>
  Si tu es content de son utilisation, n'hésite pas à faire un don sur <a href="https://donate.jw.org" target="_blank">DONATE.JW.ORG</a>.<br>
  Tu peux aussi aider aux quelques frais de développement et du serveur en m'envoyant un message. Clique sur le logo et tu seras redirigé vers mon numéro de portable.`,
        copyright: "© 2025 — Tous droits réservés"
      },
      manualDownload: {
        message: "💡 Si le téléchargement ne s'est pas effectué, appuie sur le bouton ci-dessous.",
        button: "📥 Télécharger manuellement le fichier"
      },
      messages: {
        downloadingFiles: "Téléchargement des fichiers .db, .shm, .wal...",
        filesDownloaded: "Fichiers téléchargés avec succès",
        creatingArchive: "Création de l'archive finale...",
        autoDownloadStarted: "Téléchargement automatique déclenché",
        preparingDownload: "Préparation du téléchargement manuel..."
      },
      actions: {
        manualDownload: "📥 Télécharger manuellement le fichier"
      },
      footerSecurity: `
        <div class="security-box">
          <h3>🔐 <strong>AVANT DE COMMENCER :</strong> Sécurité & Confidentialité des Fichiers</h3>
          <div class="security-columns">
            <div class="security-block">
              <p>✅ Ce site ne stocke <strong>aucun fichier de manière permanente</strong>.</p>
              <ul>
                <li>Fichiers traités en mémoire ou temporairement</li>
                <li>Supprimés après la fusion</li>
                <li>Fichier final renvoyé via HTTPS</li>
              </ul>
            </div>
            <div class="security-block">
              <p>⚠️ Le serveur est <strong>stateless</strong> :</p>
              <ul>
                <li>Sessions indépendantes</li>
                <li>Personne ne peut accéder à tes fichiers</li>
                <li>Aucun lien sauvegardé</li>
              </ul>
              <p>🌸 Données effacées après inactivité ou redémarrage</p>
            </div>
          </div>
        </div>
      `
    },
    en: {
      title: "Merge JW Library files",
      file1: "Select the first file (.jwlibrary):",
      file2: "Select the second file (.jwlibrary):",
      datetime: "Current local date and time:",
      steps: ["Loading", "Extracting", "Analyzing", "Detecting", "Ready..."],
      mergeButton: "Load, Extract & Analyze",
      summary: `Merge complete. Identical data (notes, highlights, bookmarks, playlists, etc.) has been preserved.
  Unique elements from each file have been added.<br><br>
  <strong>💡 Once the automatic download is complete, all files are immediately deleted. If the download fails, refresh the page and repeat the process.</strong>`,
      progressReady: "Ready to start...",
      final: "✅ Download complete or in progress.",
      errors: {
        selectFiles: "Please select two .jwlibrary files",
        extension: "Both files must have the .jwlibrary extension",
        missingDate: "Please provide the current local date and time",
        mergeFailed: "The merge was not completed successfully.",
        fetchError: "Error while downloading"
      },
      footer: {
        message: `This site is completely free, just like everything from Jehovah's organization.<br>
  If you find it useful, feel free to donate at <a href="https://donate.jw.org" target="_blank">DONATE.JW.ORG</a>.<br>
  You can also help with some development and server costs by sending me a message. Click on the logo to be redirected to my phone number.`,
        copyright: "© 2025 — All rights reserved"
      },
      manualDownload: {
        message: "💡 If the download didn’t start, click the button below.",
        button: "📥 Download the file manually"
      },
      messages: {
        downloadingFiles: "Téléchargement des fichiers .db, .shm, .wal...",
        filesDownloaded: "Fichiers téléchargés avec succès",
        creatingArchive: "Création de l'archive finale...",
        autoDownloadStarted: "Téléchargement automatique déclenché",
        preparingDownload: "Préparation du téléchargement manuel..."
      },
      actions: {
        manualDownload: "📥 Télécharger manuellement le fichier"
      },
      footerSecurity: `
        <div class="security-box">
          <h3>🔐 <strong>BEFORE YOU START:</strong> File Security & Privacy</h3>
          <div class="security-columns">
            <div class="security-block">
              <p>✅ This site does <strong>not store any file permanently</strong>.</p>
              <ul>
                <li>Files handled in memory or temporarily</li>
                <li>Deleted after merge</li>
                <li>Final file sent via HTTPS</li>
              </ul>
            </div>
            <div class="security-block">
              <p>⚠️ The server is <strong>stateless</strong>:</p>
              <ul>
                <li>Each session is independent</li>
                <li>No one can access your files</li>
                <li>No links are saved</li>
              </ul>
              <p>🌸 Data erased after inactivity or restart</p>
            </div>
          </div>
        </div>
      `
    },
    es: {
      title: "Fusionar archivos de JW Library",
      file1: "Selecciona el primer archivo (.jwlibrary):",
      file2: "Selecciona el segundo archivo (.jwlibrary):",
      datetime: "Fecha y hora local actual:",
      steps: ["Carga", "Extracción", "Análisis", "Detección", "Listo..."],
      mergeButton: "Cargar, Extraer y Analizar",
      summary: `La fusión ha finalizado. Los datos idénticos (notas, resaltados, marcadores, listas de reproducción, etc.) se conservaron.
  Los elementos únicos de cada archivo se han añadido.<br><br>
  <strong>💡 Una vez completada la descarga automática, todos los archivos se eliminan inmediatamente. Si la descarga falla, actualiza la página y repite el proceso completo.</strong>`,
      progressReady: "Listo para comenzar...",
      final: "✅ Descarga completada o en curso.",
      errors: {
        selectFiles: "Por favor selecciona dos archivos .jwlibrary",
        extension: "Ambos archivos deben tener la extensión .jwlibrary",
        missingDate: "Por favor indica la fecha y hora local actual",
        mergeFailed: "La fusión no se completó correctamente.",
        fetchError: "Error al descargar"
      },
      footer: {
        message: `Este sitio es completamente gratuito, como todo lo que hace la organización de Jehová.<br>
  Si estás contento con su uso, no dudes en hacer una donación en <a href="https://donate.jw.org" target="_blank">DONATE.JW.ORG</a>.<br>
  También puedes ayudar con algunos gastos de desarrollo y del servidor enviándome un mensaje. Haz clic en el logo y serás redirigido a mi número de celular.`,
        copyright: "© 2025 — Todos los derechos reservados"
      },
      manualDownload: {
        message: "💡 Si la descarga no se realizó, haz clic en el botón de abajo.",
        button: "📥 Descargar el archivo manualmente"
      },
      messages: {
        downloadingFiles: "Descargando archivos .db, .shm, .wal...",
        filesDownloaded: "Archivos descargados correctamente",
        creatingArchive: "Creando el archivo final...",
        autoDownloadStarted: "Descarga automática iniciada",
        preparingDownload: "Preparando descarga manual..."
      },
      actions: {
        manualDownload: "📥 Descargar el archivo manualmente"
      },
      footerSecurity: `
        <div class="security-box">
          <h3>🔐 <strong>ANTES DE EMPEZAR:</strong> Seguridad y Confidencialidad de los Archivos</h3>
          <div class="security-columns">
            <div class="security-block">
              <p>✅ Este sitio <strong>no guarda ningún archivo de forma permanente</strong>.</p>
              <ul>
                <li>Procesados en memoria o temporalmente</li>
                <li>Eliminados tras la fusión</li>
                <li>Archivo final enviado por HTTPS</li>
              </ul>
            </div>
            <div class="security-block">
              <p>⚠️ El servidor es <strong>stateless</strong>:</p>
              <ul>
                <li>Cada sesión es aislada</li>
                <li>Nadie puede acceder a tus archivos</li>
                <li>No se guarda ningún enlace</li>
              </ul>
              <p>🌸 Datos eliminados tras inactividad o reinicio</p>
            </div>
          </div>
        </div>
      `
    },
    it: {
      title: "Unisci file JW Library",
      file1: "Seleziona il primo file (.jwlibrary):",
      file2: "Seleziona il secondo file (.jwlibrary):",
      datetime: "Data e ora locale attuali:",
      steps: ["Caricamento", "Estrazione", "Analisi", "Rilevamento", "Pronto..."],
      mergeButton: "Carica, Estrai e Analizza",
      summary: `L'unione è completata. I dati identici (note, evidenziazioni, segnalibri, playlist, ecc.) sono stati conservati.
  Gli elementi unici di ciascun file sono stati aggiunti.<br><br>
  <strong>💡 Una volta completato il download automatico, tutti i file vengono immediatamente eliminati. Se il download fallisce, aggiorna la pagina e ripeti il processo.</strong>`,
      progressReady: "Pronto per iniziare...",
      final: "✅ Download completato o in corso.",
      errors: {
        selectFiles: "Seleziona due file .jwlibrary",
        extension: "Entrambi i file devono avere l'estensione .jwlibrary",
        missingDate: "Inserisci la data e ora locali attuali",
        mergeFailed: "L'unione non è stata completata correttamente.",
        fetchError: "Errore durante il download di"
      },
      footer: {
        message: `Questo sito è completamente gratuito, proprio come tutto ciò che fa l'organizzazione di Geova.<br>
  Se lo trovi utile, non esitare a fare una donazione su <a href="https://donate.jw.org" target="_blank">DONATE.JW.ORG</a>.<br>
  Puoi anche contribuire con alcune spese di sviluppo e del server inviandomi un messaggio. Clicca sul logo e verrai reindirizzato al mio numero di telefono.`,
        copyright: "© 2025 — Tutti i diritti riservati"
      },
      manualDownload: {
        message: "💡 Se il download non è iniziato, fai clic sul pulsante qui sotto.",
        button: "📥 Scarica il file manualmente"
      },
      messages: {
        downloadingFiles: "Download dei file .db, .shm, .wal in corso...",
        filesDownloaded: "File scaricati con successo",
        creatingArchive: "Creazione dell’archivio finale...",
        autoDownloadStarted: "Download automatico avviato",
        preparingDownload: "Preparazione del download manuale..."
      },
      actions: {
        manualDownload: "📥 Scarica il file manualmente"
      },
      footerSecurity: `
        <div class="security-box">
          <h3>🔐 <strong>PRIMA DI INIZIARE:</strong> Sicurezza e Riservatezza dei File</h3>
          <div class="security-columns">
            <div class="security-block">
              <p>✅ Questo sito <strong>non conserva file in modo permanente</strong>.</p>
              <ul>
                <li>Elaborati in memoria o temporanei</li>
                <li>Eliminati dopo la fusione</li>
                <li>File finale inviato via HTTPS</li>
              </ul>
            </div>
            <div class="security-block">
              <p>⚠️ Il server è <strong>stateless</strong>:</p>
              <ul>
                <li>Sessioni isolate</li>
                <li>Nessuno può accedere ai tuoi file</li>
                <li>Nessun link salvato</li>
              </ul>
              <p>🌸 Dati cancellati dopo inattività o riavvio</p>
            </div>
          </div>
        </div>
      `
    },
    pt: {
      title: "Mesclar arquivos JW Library",
      file1: "Selecione o primeiro arquivo (.jwlibrary):",
      file2: "Selecione o segundo arquivo (.jwlibrary):",
      datetime: "Data e hora local atual:",
      steps: ["Carregando", "Extraindo", "Analisando", "Detectando", "Pronto..."],
      mergeButton: "Carregar, Extrair e Analisar",
      summary: `A mesclagem foi concluída. Os dados idênticos (notas, destaques, marcadores, listas de reprodução, etc.) foram preservados.
  Os elementos únicos de cada arquivo foram adicionados.<br><br>
  <strong>💡 Assim que o download automático for concluído, todos os arquivos serão imediatamente excluídos. Se o download falhar, atualize a página e repita o processo.</strong>`,
      progressReady: "Pronto para começar...",
      final: "✅ Download concluído ou em andamento.",
      errors: {
        selectFiles: "Por favor selecione dois arquivos .jwlibrary",
        extension: "Ambos os arquivos devem ter a extensão .jwlibrary",
        missingDate: "Por favor informe a data e hora local atual",
        mergeFailed: "A mesclagem não foi concluída com sucesso.",
        fetchError: "Erro ao baixar"
      },
      footer: {
        message: `Este site é totalmente gratuito, assim como tudo o que a organização de Jeová faz.<br>
  Se você gostou de usá-lo, sinta-se à vontade para fazer uma doação em <a href="https://donate.jw.org" target="_blank">DONATE.JW.ORG</a>.<br>
  Você também pode ajudar com alguns custos de desenvolvimento e servidor me enviando uma mensagem. Clique no logo e será redirecionado para o meu número de telefone.`,
        copyright: "© 2025 — Todos os direitos reservados"
      },
      manualDownload: {
        message: "💡 Se o download não foi iniciado, clique no botão abaixo.",
        button: "📥 Baixar o arquivo manualmente"
      },
      messages: {
        downloadingFiles: "Baixando arquivos .db, .shm, .wal...",
        filesDownloaded: "Arquivos baixados com sucesso",
        creatingArchive: "Criando o arquivo final...",
        autoDownloadStarted: "Download automático iniciado",
        preparingDownload: "Preparando o download manual..."
      },
      actions: {
        manualDownload: "📥 Baixar o arquivo manualmente"
      },
      footerSecurity: `
        <div class="security-box">
          <h3>🔐 <strong>ANTES DE COMEÇAR:</strong> Segurança e Privacidade dos Arquivos</h3>
          <div class="security-columns">
            <div class="security-block">
              <p>✅ Este site <strong>não armazena arquivos permanentemente</strong>.</p>
              <ul>
                <li>Processados em memória ou temporários</li>
                <li>Apagados após a fusão</li>
                <li>Arquivo final enviado por HTTPS</li>
              </ul>
            </div>
            <div class="security-block">
              <p>⚠️ O servidor é <strong>stateless</strong>:</p>
              <ul>
                <li>Cada sessão é isolada</li>
                <li>Ninguém pode acessar seus arquivos</li>
                <li>Nenhum link é salvo</li>
              </ul>
              <p>🌸 Dados apagados após inatividade ou reinício</p>
            </div>
          </div>
        </div>
      `
    },
    de: {
      title: "JW Library-Dateien zusammenführen",
      file1: "Erste Datei auswählen (.jwlibrary):",
      file2: "Zweite Datei auswählen (.jwlibrary):",
      datetime: "Aktuelles lokales Datum und Uhrzeit:",
      steps: ["Laden", "Entpacken", "Analysieren", "Abgleichen", "Bereit..."],
      mergeButton: "Laden, Entpacken & Analysieren",
      summary: `Die Zusammenführung ist abgeschlossen. Identische Daten (Notizen, Hervorhebungen, Lesezeichen, Playlists usw.) wurden beibehalten.
    Einzigartige Elemente aus beiden Dateien wurden hinzugefügt.<br><br>
    <strong>💡 Nach dem automatischen Herunterladen werden alle Dateien sofort gelöscht. Falls das Herunterladen nicht funktioniert hat, lade die Seite neu und starte den Vorgang erneut.</strong>`,
      progressReady: "Bereit zum Starten...",
      final: "✅ Herunterladen abgeschlossen oder läuft.",
      errors: {
        selectFiles: "Bitte wähle zwei .jwlibrary-Dateien aus",
        extension: "Beide Dateien müssen die Endung .jwlibrary haben",
        missingDate: "Bitte gib das aktuelle lokale Datum und die Uhrzeit an",
        mergeFailed: "Die Zusammenführung wurde nicht korrekt abgeschlossen.",
        fetchError: "Fehler beim Herunterladen von"
      },
      manualDownload: {
        message: "💡 Falls der Download nicht gestartet wurde, klicke auf den Button unten.",
        button: "📥 Datei manuell herunterladen"
      },
      footer: {
        message: `Diese Seite ist vollständig kostenlos, wie alles, was Jehovas Organisation bereitstellt.<br>
    Wenn dir diese Seite gefällt, kannst du eine Spende auf <a href="https://donate.jw.org" target="_blank">DONATE.JW.ORG</a> machen.<br>
    Du kannst auch bei den kleinen Entwicklungs- und Serverkosten helfen, indem du mir eine Nachricht schickst. Klicke auf das Logo, um zu meiner Telefonnummer weitergeleitet zu werden.`,
        copyright: "© 2025 — Alle Rechte vorbehalten"
      },
      messages: {
        downloadingFiles: "Lade .db-, .shm- und .wal-Dateien herunter...",
        filesDownloaded: "Dateien erfolgreich heruntergeladen",
        creatingArchive: "Erstelle das endgültige Archiv...",
        autoDownloadStarted: "Automatischer Download gestartet",
        preparingDownload: "Manueller Download wird vorbereitet..."
      },
      actions: {
        manualDownload: "📥 Datei manuell herunterladen"
      },
      footerSecurity: `
        <div class="security-box">
          <h3>🔐 <strong>BEVOR DU BEGINNST:</strong> Sicherheit & Datenschutz</h3>
          <div class="security-columns">
            <div class="security-block">
              <p>✅ Diese Seite speichert <strong>keine Dateien dauerhaft</strong>.</p>
              <ul>
                <li>Dateien werden nur im Arbeitsspeicher oder temporär verarbeitet</li>
                <li>Nach dem Zusammenführen gelöscht</li>
                <li>Finale Datei wird per HTTPS gesendet</li>
              </ul>
            </div>
            <div class="security-block">
              <p>⚠️ Der Server ist <strong>zustandslos</strong>:</p>
              <ul>
                <li>Sitzungen sind unabhängig</li>
                <li>Niemand hat Zugriff auf deine Dateien</li>
                <li>Keine Links werden gespeichert</li>
              </ul>
              <p>🌸 Daten werden bei Inaktivität oder Neustart gelöscht</p>
            </div>
          </div>
        </div>
      `
    }
  };



  function switchLanguage(lang) {
    const t = translations[lang];
    if (!t) return;

    document.querySelector("h2").textContent = t.title;
    document.querySelector('label[for="file1"]').textContent = t.file1;
    document.querySelector('label[for="file2"]').textContent = t.file2;
    document.querySelector('label[for="local_datetime"]').textContent = t.datetime;

    const steps = document.querySelectorAll(".step div:last-child");
    steps.forEach((el, idx) => el.textContent = t.steps[idx]);

    document.getElementById("mergeButton").textContent = t.mergeButton;

    const summaryText = document.getElementById("summary-text");
    if (summaryText) summaryText.innerHTML = t.summary;

    const details = document.getElementById("progressDetails");
    if (details) details.textContent = t.progressReady;

    document.getElementById("footer-message").innerHTML = t.footer.message;
    document.getElementById("footer-copy").textContent = t.footer.copyright;

    // 🔁 Affiche uniquement le bloc de sécurité correspondant à la langue
    const allLangBlocks = document.querySelectorAll('[id^="footer-security-"]');
    allLangBlocks.forEach(el => el.style.display = 'none');

    const langBox = document.getElementById(`footer-security-${lang}`);
    if (langBox) {
      langBox.innerHTML = t.footerSecurity;
      langBox.style.display = 'grid';
    }

    // 📥 Texte du bouton et message de téléchargement manuel
    const manualMessage = document.getElementById("manualDownloadMessage");
    if (manualMessage) manualMessage.textContent = t.manualDownload.message;

    const manualBtn = document.getElementById("manualDownloadBtn");
    if (manualBtn) manualBtn.textContent = t.manualDownload.button;


    localStorage.setItem('preferredLang', lang);
    window.currentLang = lang;
  }

  window.addEventListener("DOMContentLoaded", () => {
    const savedLang = localStorage.getItem('preferredLang') || 'fr';
    switchLanguage(savedLang);
  });

   window.startMerge = startMerge;  // 👈 expose la fonction pour le HTML
   window.switchLanguage = switchLanguage;
   window.copyError = copyError;
   window.startPreparation = startPreparation;
   window.showTab = showTab;
   window.showFullNote = function(content, label = "") {
    document.getElementById("noteModalText").textContent = content;
    document.getElementById("noteModal").style.display = "flex";
   };








</script>
</body>
</html>